// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: transaction_rules.sql

package repository

import (
	"context"

	"github.com/google/uuid"
)

const createTransactionRule = `-- name: CreateTransactionRule :one
INSERT INTO transaction_rules (
    name,
    is_active,
    priority,
    conditions,
    actions,
    created_by
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, name, is_active, priority, conditions, actions, created_by, updated_by, created_at, updated_at, deleted_at
`

type CreateTransactionRuleParams struct {
	Name       string    `json:"name"`
	IsActive   *bool     `json:"is_active"`
	Priority   *int32    `json:"priority"`
	Conditions []byte    `json:"conditions"`
	Actions    []byte    `json:"actions"`
	CreatedBy  uuid.UUID `json:"created_by"`
}

func (q *Queries) CreateTransactionRule(ctx context.Context, arg CreateTransactionRuleParams) (TransactionRule, error) {
	row := q.db.QueryRow(ctx, createTransactionRule,
		arg.Name,
		arg.IsActive,
		arg.Priority,
		arg.Conditions,
		arg.Actions,
		arg.CreatedBy,
	)
	var i TransactionRule
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.IsActive,
		&i.Priority,
		&i.Conditions,
		&i.Actions,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteTransactionRule = `-- name: DeleteTransactionRule :exec
UPDATE transaction_rules
SET deleted_at = current_timestamp
WHERE id = $1 AND created_by = $2
`

type DeleteTransactionRuleParams struct {
	ID        uuid.UUID `json:"id"`
	CreatedBy uuid.UUID `json:"created_by"`
}

func (q *Queries) DeleteTransactionRule(ctx context.Context, arg DeleteTransactionRuleParams) error {
	_, err := q.db.Exec(ctx, deleteTransactionRule, arg.ID, arg.CreatedBy)
	return err
}

const getTransactionRuleById = `-- name: GetTransactionRuleById :one
SELECT id, name, is_active, priority, conditions, actions, created_by, updated_by, created_at, updated_at, deleted_at FROM transaction_rules
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetTransactionRuleById(ctx context.Context, id uuid.UUID) (TransactionRule, error) {
	row := q.db.QueryRow(ctx, getTransactionRuleById, id)
	var i TransactionRule
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.IsActive,
		&i.Priority,
		&i.Conditions,
		&i.Actions,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const listActiveTransactionRules = `-- name: ListActiveTransactionRules :many
SELECT id, name, is_active, priority, conditions, actions, created_by, updated_by, created_at, updated_at, deleted_at FROM transaction_rules
WHERE created_by = $1 AND is_active = TRUE AND deleted_at IS NULL
ORDER BY priority DESC, created_at DESC
`

func (q *Queries) ListActiveTransactionRules(ctx context.Context, createdBy uuid.UUID) ([]TransactionRule, error) {
	rows, err := q.db.Query(ctx, listActiveTransactionRules, createdBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TransactionRule{}
	for rows.Next() {
		var i TransactionRule
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.IsActive,
			&i.Priority,
			&i.Conditions,
			&i.Actions,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactionRules = `-- name: ListTransactionRules :many
SELECT id, name, is_active, priority, conditions, actions, created_by, updated_by, created_at, updated_at, deleted_at FROM transaction_rules
WHERE created_by = $1 AND deleted_at IS NULL
ORDER BY priority DESC, created_at DESC
`

func (q *Queries) ListTransactionRules(ctx context.Context, createdBy uuid.UUID) ([]TransactionRule, error) {
	rows, err := q.db.Query(ctx, listTransactionRules, createdBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TransactionRule{}
	for rows.Next() {
		var i TransactionRule
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.IsActive,
			&i.Priority,
			&i.Conditions,
			&i.Actions,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const toggleTransactionRuleActive = `-- name: ToggleTransactionRuleActive :one
UPDATE transaction_rules
SET
    is_active = NOT is_active,
    updated_by = $1,
    updated_at = current_timestamp
WHERE id = $2 AND created_by = $1 AND deleted_at IS NULL
RETURNING id, name, is_active, priority, conditions, actions, created_by, updated_by, created_at, updated_at, deleted_at
`

type ToggleTransactionRuleActiveParams struct {
	UpdatedBy *uuid.UUID `json:"updated_by"`
	ID        uuid.UUID  `json:"id"`
}

func (q *Queries) ToggleTransactionRuleActive(ctx context.Context, arg ToggleTransactionRuleActiveParams) (TransactionRule, error) {
	row := q.db.QueryRow(ctx, toggleTransactionRuleActive, arg.UpdatedBy, arg.ID)
	var i TransactionRule
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.IsActive,
		&i.Priority,
		&i.Conditions,
		&i.Actions,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateTransactionRule = `-- name: UpdateTransactionRule :one
UPDATE transaction_rules
SET
    name = coalesce($3, name),
    is_active = coalesce($4, is_active),
    priority = coalesce($5, priority),
    conditions = coalesce($6, conditions),
    actions = coalesce($7, actions),
    updated_by = $1,
    updated_at = current_timestamp
WHERE id = $2 AND deleted_at IS NULL
RETURNING id, name, is_active, priority, conditions, actions, created_by, updated_by, created_at, updated_at, deleted_at
`

type UpdateTransactionRuleParams struct {
	UpdatedBy  *uuid.UUID `json:"updated_by"`
	ID         uuid.UUID  `json:"id"`
	Name       *string    `json:"name"`
	IsActive   *bool      `json:"is_active"`
	Priority   *int32     `json:"priority"`
	Conditions []byte     `json:"conditions"`
	Actions    []byte     `json:"actions"`
}

func (q *Queries) UpdateTransactionRule(ctx context.Context, arg UpdateTransactionRuleParams) (TransactionRule, error) {
	row := q.db.QueryRow(ctx, updateTransactionRule,
		arg.UpdatedBy,
		arg.ID,
		arg.Name,
		arg.IsActive,
		arg.Priority,
		arg.Conditions,
		arg.Actions,
	)
	var i TransactionRule
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.IsActive,
		&i.Priority,
		&i.Conditions,
		&i.Actions,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
