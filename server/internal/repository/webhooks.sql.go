// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: webhooks.sql

package repository

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const cleanupOldWebhookEvents = `-- name: CleanupOldWebhookEvents :exec
DELETE FROM webhook_events
WHERE
    created_at < now() - INTERVAL '30 days'
    AND status IN ('sent', 'failed')
`

func (q *Queries) CleanupOldWebhookEvents(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanupOldWebhookEvents)
	return err
}

const createWebhookEvent = `-- name: CreateWebhookEvent :one
INSERT INTO webhook_events (
    subscription_id,
    event_type,
    payload,
    status
) VALUES (
    $1, $2, $3, $4
) RETURNING id, subscription_id, event_type, payload, status, attempts, last_attempt, created_at
`

type CreateWebhookEventParams struct {
	SubscriptionID uuid.UUID `json:"subscription_id"`
	EventType      string    `json:"event_type"`
	Payload        []byte    `json:"payload"`
	Status         *string   `json:"status"`
}

func (q *Queries) CreateWebhookEvent(ctx context.Context, arg CreateWebhookEventParams) (WebhookEvent, error) {
	row := q.db.QueryRow(ctx, createWebhookEvent,
		arg.SubscriptionID,
		arg.EventType,
		arg.Payload,
		arg.Status,
	)
	var i WebhookEvent
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.EventType,
		&i.Payload,
		&i.Status,
		&i.Attempts,
		&i.LastAttempt,
		&i.CreatedAt,
	)
	return i, err
}

const createWebhookSubscription = `-- name: CreateWebhookSubscription :one
INSERT INTO webhook_subscriptions (
    user_id,
    event,
    active,
    endpoint_url,
    secret
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, user_id, event, active, endpoint_url, secret, created_at
`

type CreateWebhookSubscriptionParams struct {
	UserID      uuid.UUID `json:"user_id"`
	Event       []string  `json:"event"`
	Active      bool      `json:"active"`
	EndpointUrl string    `json:"endpoint_url"`
	Secret      string    `json:"secret"`
}

func (q *Queries) CreateWebhookSubscription(ctx context.Context, arg CreateWebhookSubscriptionParams) (WebhookSubscription, error) {
	row := q.db.QueryRow(ctx, createWebhookSubscription,
		arg.UserID,
		arg.Event,
		arg.Active,
		arg.EndpointUrl,
		arg.Secret,
	)
	var i WebhookSubscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Event,
		&i.Active,
		&i.EndpointUrl,
		&i.Secret,
		&i.CreatedAt,
	)
	return i, err
}

const deleteWebhookEvent = `-- name: DeleteWebhookEvent :exec
DELETE FROM webhook_events
WHERE id = $1
`

func (q *Queries) DeleteWebhookEvent(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteWebhookEvent, id)
	return err
}

const deleteWebhookSubscription = `-- name: DeleteWebhookSubscription :exec
DELETE FROM webhook_subscriptions
WHERE
    id = $1
    AND user_id = $2
`

type DeleteWebhookSubscriptionParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) DeleteWebhookSubscription(ctx context.Context, arg DeleteWebhookSubscriptionParams) error {
	_, err := q.db.Exec(ctx, deleteWebhookSubscription, arg.ID, arg.UserID)
	return err
}

const getPendingWebhookEvents = `-- name: GetPendingWebhookEvents :many
SELECT
    id,
    subscription_id,
    event_type,
    payload,
    status,
    attempts,
    last_attempt,
    created_at
FROM webhook_events
WHERE
    status IN ('pending', 'retrying')
    AND (last_attempt IS NULL OR last_attempt < now() - INTERVAL '5 minutes')
    AND attempts < 5
ORDER BY created_at
LIMIT $1
`

func (q *Queries) GetPendingWebhookEvents(ctx context.Context, limit int32) ([]WebhookEvent, error) {
	rows, err := q.db.Query(ctx, getPendingWebhookEvents, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WebhookEvent{}
	for rows.Next() {
		var i WebhookEvent
		if err := rows.Scan(
			&i.ID,
			&i.SubscriptionID,
			&i.EventType,
			&i.Payload,
			&i.Status,
			&i.Attempts,
			&i.LastAttempt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWebhookEventById = `-- name: GetWebhookEventById :one
SELECT
    id,
    subscription_id,
    event_type,
    payload,
    status,
    attempts,
    last_attempt,
    created_at
FROM webhook_events
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetWebhookEventById(ctx context.Context, id uuid.UUID) (WebhookEvent, error) {
	row := q.db.QueryRow(ctx, getWebhookEventById, id)
	var i WebhookEvent
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.EventType,
		&i.Payload,
		&i.Status,
		&i.Attempts,
		&i.LastAttempt,
		&i.CreatedAt,
	)
	return i, err
}

const getWebhookEventsBySubscriptionId = `-- name: GetWebhookEventsBySubscriptionId :many
SELECT
    id,
    subscription_id,
    event_type,
    payload,
    status,
    attempts,
    last_attempt,
    created_at
FROM webhook_events
WHERE subscription_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetWebhookEventsBySubscriptionId(ctx context.Context, subscriptionID uuid.UUID) ([]WebhookEvent, error) {
	rows, err := q.db.Query(ctx, getWebhookEventsBySubscriptionId, subscriptionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WebhookEvent{}
	for rows.Next() {
		var i WebhookEvent
		if err := rows.Scan(
			&i.ID,
			&i.SubscriptionID,
			&i.EventType,
			&i.Payload,
			&i.Status,
			&i.Attempts,
			&i.LastAttempt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWebhookSubscriptionById = `-- name: GetWebhookSubscriptionById :one
SELECT
    id,
    user_id,
    event,
    active,
    endpoint_url,
    secret,
    created_at
FROM webhook_subscriptions
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetWebhookSubscriptionById(ctx context.Context, id uuid.UUID) (WebhookSubscription, error) {
	row := q.db.QueryRow(ctx, getWebhookSubscriptionById, id)
	var i WebhookSubscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Event,
		&i.Active,
		&i.EndpointUrl,
		&i.Secret,
		&i.CreatedAt,
	)
	return i, err
}

const getWebhookSubscriptionsByEvent = `-- name: GetWebhookSubscriptionsByEvent :many
SELECT
    id,
    user_id,
    event,
    active,
    endpoint_url,
    secret,
    created_at
FROM webhook_subscriptions
WHERE $1 = ANY(event)
ORDER BY created_at
`

func (q *Queries) GetWebhookSubscriptionsByEvent(ctx context.Context, event []string) ([]WebhookSubscription, error) {
	rows, err := q.db.Query(ctx, getWebhookSubscriptionsByEvent, event)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WebhookSubscription{}
	for rows.Next() {
		var i WebhookSubscription
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Event,
			&i.Active,
			&i.EndpointUrl,
			&i.Secret,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWebhookSubscriptionsByUserId = `-- name: GetWebhookSubscriptionsByUserId :many
SELECT
    id,
    user_id,
    event,
    active,
    endpoint_url,
    secret,
    created_at
FROM webhook_subscriptions
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetWebhookSubscriptionsByUserId(ctx context.Context, userID uuid.UUID) ([]WebhookSubscription, error) {
	rows, err := q.db.Query(ctx, getWebhookSubscriptionsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WebhookSubscription{}
	for rows.Next() {
		var i WebhookSubscription
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Event,
			&i.Active,
			&i.EndpointUrl,
			&i.Secret,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWebhookSubscriptions = `-- name: ListWebhookSubscriptions :many
SELECT
    id,
    user_id,
    active,
    event,
    endpoint_url,
    secret,
    created_at
FROM webhook_subscriptions
ORDER BY created_at DESC
LIMIT
    $1
    OFFSET $2
`

type ListWebhookSubscriptionsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListWebhookSubscriptionsRow struct {
	ID          uuid.UUID        `json:"id"`
	UserID      uuid.UUID        `json:"user_id"`
	Active      bool             `json:"active"`
	Event       []string         `json:"event"`
	EndpointUrl string           `json:"endpoint_url"`
	Secret      string           `json:"secret"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) ListWebhookSubscriptions(ctx context.Context, arg ListWebhookSubscriptionsParams) ([]ListWebhookSubscriptionsRow, error) {
	rows, err := q.db.Query(ctx, listWebhookSubscriptions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListWebhookSubscriptionsRow{}
	for rows.Next() {
		var i ListWebhookSubscriptionsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Active,
			&i.Event,
			&i.EndpointUrl,
			&i.Secret,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateWebhookEventStatus = `-- name: UpdateWebhookEventStatus :one
UPDATE webhook_events
SET
    status = $2,
    attempts = attempts + 1,
    last_attempt = now()
WHERE id = $1
RETURNING id, subscription_id, event_type, payload, status, attempts, last_attempt, created_at
`

type UpdateWebhookEventStatusParams struct {
	ID     uuid.UUID `json:"id"`
	Status *string   `json:"status"`
}

func (q *Queries) UpdateWebhookEventStatus(ctx context.Context, arg UpdateWebhookEventStatusParams) (WebhookEvent, error) {
	row := q.db.QueryRow(ctx, updateWebhookEventStatus, arg.ID, arg.Status)
	var i WebhookEvent
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.EventType,
		&i.Payload,
		&i.Status,
		&i.Attempts,
		&i.LastAttempt,
		&i.CreatedAt,
	)
	return i, err
}

const updateWebhookSubscription = `-- name: UpdateWebhookSubscription :one
UPDATE webhook_subscriptions
SET
    event = coalesce($1, event),
    endpoint_url = coalesce($2, endpoint_url),
    secret = coalesce($3, secret),
    active = coalesce($4, active)
WHERE
    id = $5
    AND user_id = $6
RETURNING id, user_id, event, active, endpoint_url, secret, created_at
`

type UpdateWebhookSubscriptionParams struct {
	Event       []string  `json:"event"`
	EndpointUrl *string   `json:"endpoint_url"`
	Secret      *string   `json:"secret"`
	Active      *bool     `json:"active"`
	ID          uuid.UUID `json:"id"`
	UserID      uuid.UUID `json:"user_id"`
}

func (q *Queries) UpdateWebhookSubscription(ctx context.Context, arg UpdateWebhookSubscriptionParams) (WebhookSubscription, error) {
	row := q.db.QueryRow(ctx, updateWebhookSubscription,
		arg.Event,
		arg.EndpointUrl,
		arg.Secret,
		arg.Active,
		arg.ID,
		arg.UserID,
	)
	var i WebhookSubscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Event,
		&i.Active,
		&i.EndpointUrl,
		&i.Secret,
		&i.CreatedAt,
	)
	return i, err
}
