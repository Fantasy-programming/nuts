// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: recurring_transactions.sql

package repository

import (
	"context"
	"time"

	"github.com/Fantasy-Programming/nuts/server/internal/repository/dto"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const countRecurringTransactionsWithFilters = `-- name: CountRecurringTransactionsWithFilters :one
SELECT COUNT(*) FROM recurring_transactions
WHERE user_id = $1 
    AND deleted_at IS NULL
    AND ($2::uuid IS NULL OR account_id = $2)
    AND ($3::uuid IS NULL OR category_id = $3)
    AND ($4::text IS NULL OR frequency = $4)
    AND ($5::boolean IS NULL OR is_paused = $5)
    AND ($6::boolean IS NULL OR auto_post = $6)
    AND ($7::text IS NULL OR template_name ILIKE '%' || $7 || '%')
`

type CountRecurringTransactionsWithFiltersParams struct {
	UserID       uuid.UUID  `json:"user_id"`
	AccountID    *uuid.UUID `json:"account_id"`
	CategoryID   *uuid.UUID `json:"category_id"`
	Frequency    *string    `json:"frequency"`
	IsPaused     *bool      `json:"is_paused"`
	AutoPost     *bool      `json:"auto_post"`
	TemplateName *string    `json:"template_name"`
}

func (q *Queries) CountRecurringTransactionsWithFilters(ctx context.Context, arg CountRecurringTransactionsWithFiltersParams) (int64, error) {
	row := q.db.QueryRow(ctx, countRecurringTransactionsWithFilters,
		arg.UserID,
		arg.AccountID,
		arg.CategoryID,
		arg.Frequency,
		arg.IsPaused,
		arg.AutoPost,
		arg.TemplateName,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createRecurringTransaction = `-- name: CreateRecurringTransaction :one
INSERT INTO recurring_transactions (
    user_id,
    account_id,
    category_id,
    destination_account_id,
    amount,
    type,
    description,
    details,
    frequency,
    frequency_interval,
    frequency_data,
    start_date,
    end_date,
    next_due_date,
    auto_post,
    is_paused,
    max_occurrences,
    template_name,
    tags
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19
) RETURNING id, user_id, account_id, category_id, destination_account_id, amount, type, description, details, frequency, frequency_interval, frequency_data, start_date, end_date, last_generated_date, next_due_date, auto_post, is_paused, max_occurrences, occurrences_count, template_name, tags, created_at, updated_at, deleted_at
`

type CreateRecurringTransactionParams struct {
	UserID               uuid.UUID          `json:"user_id"`
	AccountID            uuid.UUID          `json:"account_id"`
	CategoryID           *uuid.UUID         `json:"category_id"`
	DestinationAccountID *uuid.UUID         `json:"destination_account_id"`
	Amount               decimal.Decimal    `json:"amount"`
	Type                 string             `json:"type"`
	Description          *string            `json:"description"`
	Details              *dto.Details       `json:"details"`
	Frequency            string             `json:"frequency"`
	FrequencyInterval    int32              `json:"frequency_interval"`
	FrequencyData        []byte             `json:"frequency_data"`
	StartDate            pgtype.Timestamptz `json:"start_date"`
	EndDate              pgtype.Timestamptz `json:"end_date"`
	NextDueDate          pgtype.Timestamptz `json:"next_due_date"`
	AutoPost             bool               `json:"auto_post"`
	IsPaused             bool               `json:"is_paused"`
	MaxOccurrences       *int32             `json:"max_occurrences"`
	TemplateName         *string            `json:"template_name"`
	Tags                 []byte             `json:"tags"`
}

func (q *Queries) CreateRecurringTransaction(ctx context.Context, arg CreateRecurringTransactionParams) (RecurringTransaction, error) {
	row := q.db.QueryRow(ctx, createRecurringTransaction,
		arg.UserID,
		arg.AccountID,
		arg.CategoryID,
		arg.DestinationAccountID,
		arg.Amount,
		arg.Type,
		arg.Description,
		arg.Details,
		arg.Frequency,
		arg.FrequencyInterval,
		arg.FrequencyData,
		arg.StartDate,
		arg.EndDate,
		arg.NextDueDate,
		arg.AutoPost,
		arg.IsPaused,
		arg.MaxOccurrences,
		arg.TemplateName,
		arg.Tags,
	)
	var i RecurringTransaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AccountID,
		&i.CategoryID,
		&i.DestinationAccountID,
		&i.Amount,
		&i.Type,
		&i.Description,
		&i.Details,
		&i.Frequency,
		&i.FrequencyInterval,
		&i.FrequencyData,
		&i.StartDate,
		&i.EndDate,
		&i.LastGeneratedDate,
		&i.NextDueDate,
		&i.AutoPost,
		&i.IsPaused,
		&i.MaxOccurrences,
		&i.OccurrencesCount,
		&i.TemplateName,
		&i.Tags,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteRecurringTransaction = `-- name: DeleteRecurringTransaction :exec
UPDATE recurring_transactions
SET deleted_at = current_timestamp
WHERE id = $1 AND user_id = $2
`

type DeleteRecurringTransactionParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) DeleteRecurringTransaction(ctx context.Context, arg DeleteRecurringTransactionParams) error {
	_, err := q.db.Exec(ctx, deleteRecurringTransaction, arg.ID, arg.UserID)
	return err
}

const getActiveRecurringTransactions = `-- name: GetActiveRecurringTransactions :many
SELECT id, user_id, account_id, category_id, destination_account_id, amount, type, description, details, frequency, frequency_interval, frequency_data, start_date, end_date, last_generated_date, next_due_date, auto_post, is_paused, max_occurrences, occurrences_count, template_name, tags, created_at, updated_at, deleted_at FROM recurring_transactions
WHERE deleted_at IS NULL 
    AND is_paused = FALSE
    AND (max_occurrences IS NULL OR occurrences_count < max_occurrences)
    AND (end_date IS NULL OR $1 <= end_date)
ORDER BY next_due_date ASC
`

func (q *Queries) GetActiveRecurringTransactions(ctx context.Context, endDate pgtype.Timestamptz) ([]RecurringTransaction, error) {
	rows, err := q.db.Query(ctx, getActiveRecurringTransactions, endDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RecurringTransaction{}
	for rows.Next() {
		var i RecurringTransaction
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AccountID,
			&i.CategoryID,
			&i.DestinationAccountID,
			&i.Amount,
			&i.Type,
			&i.Description,
			&i.Details,
			&i.Frequency,
			&i.FrequencyInterval,
			&i.FrequencyData,
			&i.StartDate,
			&i.EndDate,
			&i.LastGeneratedDate,
			&i.NextDueDate,
			&i.AutoPost,
			&i.IsPaused,
			&i.MaxOccurrences,
			&i.OccurrencesCount,
			&i.TemplateName,
			&i.Tags,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDueRecurringTransactions = `-- name: GetDueRecurringTransactions :many
SELECT id, user_id, account_id, category_id, destination_account_id, amount, type, description, details, frequency, frequency_interval, frequency_data, start_date, end_date, last_generated_date, next_due_date, auto_post, is_paused, max_occurrences, occurrences_count, template_name, tags, created_at, updated_at, deleted_at FROM recurring_transactions
WHERE deleted_at IS NULL 
    AND is_paused = FALSE
    AND next_due_date <= $1
    AND (max_occurrences IS NULL OR occurrences_count < max_occurrences)
    AND (end_date IS NULL OR next_due_date <= end_date)
ORDER BY next_due_date ASC
`

func (q *Queries) GetDueRecurringTransactions(ctx context.Context, nextDueDate pgtype.Timestamptz) ([]RecurringTransaction, error) {
	rows, err := q.db.Query(ctx, getDueRecurringTransactions, nextDueDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RecurringTransaction{}
	for rows.Next() {
		var i RecurringTransaction
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AccountID,
			&i.CategoryID,
			&i.DestinationAccountID,
			&i.Amount,
			&i.Type,
			&i.Description,
			&i.Details,
			&i.Frequency,
			&i.FrequencyInterval,
			&i.FrequencyData,
			&i.StartDate,
			&i.EndDate,
			&i.LastGeneratedDate,
			&i.NextDueDate,
			&i.AutoPost,
			&i.IsPaused,
			&i.MaxOccurrences,
			&i.OccurrencesCount,
			&i.TemplateName,
			&i.Tags,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecurringTransactionById = `-- name: GetRecurringTransactionById :one
SELECT id, user_id, account_id, category_id, destination_account_id, amount, type, description, details, frequency, frequency_interval, frequency_data, start_date, end_date, last_generated_date, next_due_date, auto_post, is_paused, max_occurrences, occurrences_count, template_name, tags, created_at, updated_at, deleted_at FROM recurring_transactions
WHERE id = $1 AND user_id = $2 AND deleted_at IS NULL
`

type GetRecurringTransactionByIdParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) GetRecurringTransactionById(ctx context.Context, arg GetRecurringTransactionByIdParams) (RecurringTransaction, error) {
	row := q.db.QueryRow(ctx, getRecurringTransactionById, arg.ID, arg.UserID)
	var i RecurringTransaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AccountID,
		&i.CategoryID,
		&i.DestinationAccountID,
		&i.Amount,
		&i.Type,
		&i.Description,
		&i.Details,
		&i.Frequency,
		&i.FrequencyInterval,
		&i.FrequencyData,
		&i.StartDate,
		&i.EndDate,
		&i.LastGeneratedDate,
		&i.NextDueDate,
		&i.AutoPost,
		&i.IsPaused,
		&i.MaxOccurrences,
		&i.OccurrencesCount,
		&i.TemplateName,
		&i.Tags,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getRecurringTransactionInstances = `-- name: GetRecurringTransactionInstances :many
SELECT 
    t.id, t.amount, t.type, t.account_id, t.category_id, t.destination_account_id, t.transaction_datetime, t.description, t.details, t.created_by, t.updated_by, t.created_at, t.updated_at, t.deleted_at, t.is_external, t.provider_transaction_id, t.transaction_currency, t.original_amount, t.exchange_rate, t.exchange_rate_date, t.is_categorized, t.shared_finance_id, t.recurring_transaction_id, t.recurring_instance_date,
    rt.template_name,
    rt.frequency
FROM transactions t
JOIN recurring_transactions rt ON t.recurring_transaction_id = rt.id
WHERE rt.user_id = $1 AND rt.id = $2 AND t.deleted_at IS NULL
ORDER BY t.transaction_datetime DESC
`

type GetRecurringTransactionInstancesParams struct {
	UserID uuid.UUID `json:"user_id"`
	ID     uuid.UUID `json:"id"`
}

type GetRecurringTransactionInstancesRow struct {
	ID                     uuid.UUID      `json:"id"`
	Amount                 pgtype.Numeric `json:"amount"`
	Type                   string         `json:"type"`
	AccountID              uuid.UUID      `json:"account_id"`
	CategoryID             *uuid.UUID     `json:"category_id"`
	DestinationAccountID   *uuid.UUID     `json:"destination_account_id"`
	TransactionDatetime    time.Time      `json:"transaction_datetime"`
	Description            *string        `json:"description"`
	Details                *dto.Details   `json:"details"`
	CreatedBy              *uuid.UUID     `json:"created_by"`
	UpdatedBy              *uuid.UUID     `json:"updated_by"`
	CreatedAt              time.Time      `json:"created_at"`
	UpdatedAt              time.Time      `json:"updated_at"`
	DeletedAt              *time.Time     `json:"deleted_at"`
	IsExternal             *bool          `json:"is_external"`
	ProviderTransactionID  *string        `json:"provider_transaction_id"`
	TransactionCurrency    string         `json:"transaction_currency"`
	OriginalAmount         pgtype.Numeric `json:"original_amount"`
	ExchangeRate           pgtype.Numeric `json:"exchange_rate"`
	ExchangeRateDate       pgtype.Date    `json:"exchange_rate_date"`
	IsCategorized          *bool          `json:"is_categorized"`
	SharedFinanceID        *uuid.UUID     `json:"shared_finance_id"`
	RecurringTransactionID *uuid.UUID     `json:"recurring_transaction_id"`
	RecurringInstanceDate  *time.Time     `json:"recurring_instance_date"`
	TemplateName           *string        `json:"template_name"`
	Frequency              string         `json:"frequency"`
}

func (q *Queries) GetRecurringTransactionInstances(ctx context.Context, arg GetRecurringTransactionInstancesParams) ([]GetRecurringTransactionInstancesRow, error) {
	rows, err := q.db.Query(ctx, getRecurringTransactionInstances, arg.UserID, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecurringTransactionInstancesRow{}
	for rows.Next() {
		var i GetRecurringTransactionInstancesRow
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.Type,
			&i.AccountID,
			&i.CategoryID,
			&i.DestinationAccountID,
			&i.TransactionDatetime,
			&i.Description,
			&i.Details,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.IsExternal,
			&i.ProviderTransactionID,
			&i.TransactionCurrency,
			&i.OriginalAmount,
			&i.ExchangeRate,
			&i.ExchangeRateDate,
			&i.IsCategorized,
			&i.SharedFinanceID,
			&i.RecurringTransactionID,
			&i.RecurringInstanceDate,
			&i.TemplateName,
			&i.Frequency,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecurringTransactionStats = `-- name: GetRecurringTransactionStats :one
SELECT
    COUNT(*) as total_count,
    COUNT(*) FILTER (WHERE is_paused = FALSE) as active_count,
    COUNT(*) FILTER (WHERE is_paused = TRUE) as paused_count,
    COUNT(*) FILTER (WHERE next_due_date <= current_timestamp AND is_paused = FALSE) as due_count
FROM recurring_transactions
WHERE user_id = $1 AND deleted_at IS NULL
`

type GetRecurringTransactionStatsRow struct {
	TotalCount  int64 `json:"total_count"`
	ActiveCount int64 `json:"active_count"`
	PausedCount int64 `json:"paused_count"`
	DueCount    int64 `json:"due_count"`
}

func (q *Queries) GetRecurringTransactionStats(ctx context.Context, userID uuid.UUID) (GetRecurringTransactionStatsRow, error) {
	row := q.db.QueryRow(ctx, getRecurringTransactionStats, userID)
	var i GetRecurringTransactionStatsRow
	err := row.Scan(
		&i.TotalCount,
		&i.ActiveCount,
		&i.PausedCount,
		&i.DueCount,
	)
	return i, err
}

const getTransactionByRecurringAndDate = `-- name: GetTransactionByRecurringAndDate :one
SELECT id, amount, type, account_id, category_id, destination_account_id, transaction_datetime, description, details, created_by, updated_by, created_at, updated_at, deleted_at, is_external, provider_transaction_id, transaction_currency, original_amount, exchange_rate, exchange_rate_date, is_categorized, shared_finance_id, recurring_transaction_id, recurring_instance_date FROM transactions
WHERE recurring_transaction_id = $1
    AND DATE(transaction_datetime) = DATE($2)
    AND deleted_at IS NULL
LIMIT 1
`

type GetTransactionByRecurringAndDateParams struct {
	RecurringTransactionID *uuid.UUID         `json:"recurring_transaction_id"`
	Date                   pgtype.Timestamptz `json:"date"`
}

func (q *Queries) GetTransactionByRecurringAndDate(ctx context.Context, arg GetTransactionByRecurringAndDateParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, getTransactionByRecurringAndDate, arg.RecurringTransactionID, arg.Date)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.Type,
		&i.AccountID,
		&i.CategoryID,
		&i.DestinationAccountID,
		&i.TransactionDatetime,
		&i.Description,
		&i.Details,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.IsExternal,
		&i.ProviderTransactionID,
		&i.TransactionCurrency,
		&i.OriginalAmount,
		&i.ExchangeRate,
		&i.ExchangeRateDate,
		&i.IsCategorized,
		&i.SharedFinanceID,
		&i.RecurringTransactionID,
		&i.RecurringInstanceDate,
	)
	return i, err
}

const getUpcomingRecurringTransactions = `-- name: GetUpcomingRecurringTransactions :many
SELECT id, user_id, account_id, category_id, destination_account_id, amount, type, description, details, frequency, frequency_interval, frequency_data, start_date, end_date, last_generated_date, next_due_date, auto_post, is_paused, max_occurrences, occurrences_count, template_name, tags, created_at, updated_at, deleted_at FROM recurring_transactions
WHERE user_id = $1 
    AND deleted_at IS NULL
    AND is_paused = FALSE
    AND next_due_date BETWEEN $2 AND $3
    AND (max_occurrences IS NULL OR occurrences_count < max_occurrences)
    AND (end_date IS NULL OR next_due_date <= end_date)
ORDER BY next_due_date ASC
`

type GetUpcomingRecurringTransactionsParams struct {
	UserID        uuid.UUID          `json:"user_id"`
	NextDueDate   pgtype.Timestamptz `json:"next_due_date"`
	NextDueDate_2 pgtype.Timestamptz `json:"next_due_date_2"`
}

func (q *Queries) GetUpcomingRecurringTransactions(ctx context.Context, arg GetUpcomingRecurringTransactionsParams) ([]RecurringTransaction, error) {
	rows, err := q.db.Query(ctx, getUpcomingRecurringTransactions, arg.UserID, arg.NextDueDate, arg.NextDueDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RecurringTransaction{}
	for rows.Next() {
		var i RecurringTransaction
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AccountID,
			&i.CategoryID,
			&i.DestinationAccountID,
			&i.Amount,
			&i.Type,
			&i.Description,
			&i.Details,
			&i.Frequency,
			&i.FrequencyInterval,
			&i.FrequencyData,
			&i.StartDate,
			&i.EndDate,
			&i.LastGeneratedDate,
			&i.NextDueDate,
			&i.AutoPost,
			&i.IsPaused,
			&i.MaxOccurrences,
			&i.OccurrencesCount,
			&i.TemplateName,
			&i.Tags,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecurringTransactions = `-- name: ListRecurringTransactions :many
SELECT id, user_id, account_id, category_id, destination_account_id, amount, type, description, details, frequency, frequency_interval, frequency_data, start_date, end_date, last_generated_date, next_due_date, auto_post, is_paused, max_occurrences, occurrences_count, template_name, tags, created_at, updated_at, deleted_at FROM recurring_transactions
WHERE user_id = $1 AND deleted_at IS NULL
ORDER BY next_due_date ASC
`

func (q *Queries) ListRecurringTransactions(ctx context.Context, userID uuid.UUID) ([]RecurringTransaction, error) {
	rows, err := q.db.Query(ctx, listRecurringTransactions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RecurringTransaction{}
	for rows.Next() {
		var i RecurringTransaction
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AccountID,
			&i.CategoryID,
			&i.DestinationAccountID,
			&i.Amount,
			&i.Type,
			&i.Description,
			&i.Details,
			&i.Frequency,
			&i.FrequencyInterval,
			&i.FrequencyData,
			&i.StartDate,
			&i.EndDate,
			&i.LastGeneratedDate,
			&i.NextDueDate,
			&i.AutoPost,
			&i.IsPaused,
			&i.MaxOccurrences,
			&i.OccurrencesCount,
			&i.TemplateName,
			&i.Tags,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecurringTransactionsByAccount = `-- name: ListRecurringTransactionsByAccount :many
SELECT id, user_id, account_id, category_id, destination_account_id, amount, type, description, details, frequency, frequency_interval, frequency_data, start_date, end_date, last_generated_date, next_due_date, auto_post, is_paused, max_occurrences, occurrences_count, template_name, tags, created_at, updated_at, deleted_at FROM recurring_transactions
WHERE user_id = $1 AND account_id = $2 AND deleted_at IS NULL
ORDER BY next_due_date ASC
`

type ListRecurringTransactionsByAccountParams struct {
	UserID    uuid.UUID `json:"user_id"`
	AccountID uuid.UUID `json:"account_id"`
}

func (q *Queries) ListRecurringTransactionsByAccount(ctx context.Context, arg ListRecurringTransactionsByAccountParams) ([]RecurringTransaction, error) {
	rows, err := q.db.Query(ctx, listRecurringTransactionsByAccount, arg.UserID, arg.AccountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RecurringTransaction{}
	for rows.Next() {
		var i RecurringTransaction
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AccountID,
			&i.CategoryID,
			&i.DestinationAccountID,
			&i.Amount,
			&i.Type,
			&i.Description,
			&i.Details,
			&i.Frequency,
			&i.FrequencyInterval,
			&i.FrequencyData,
			&i.StartDate,
			&i.EndDate,
			&i.LastGeneratedDate,
			&i.NextDueDate,
			&i.AutoPost,
			&i.IsPaused,
			&i.MaxOccurrences,
			&i.OccurrencesCount,
			&i.TemplateName,
			&i.Tags,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecurringTransactionsWithFilters = `-- name: ListRecurringTransactionsWithFilters :many
SELECT id, user_id, account_id, category_id, destination_account_id, amount, type, description, details, frequency, frequency_interval, frequency_data, start_date, end_date, last_generated_date, next_due_date, auto_post, is_paused, max_occurrences, occurrences_count, template_name, tags, created_at, updated_at, deleted_at FROM recurring_transactions
WHERE user_id = $1 
    AND deleted_at IS NULL
    AND ($2::uuid IS NULL OR account_id = $2)
    AND ($3::uuid IS NULL OR category_id = $3)
    AND ($4::text IS NULL OR frequency = $4)
    AND ($5::boolean IS NULL OR is_paused = $5)
    AND ($6::boolean IS NULL OR auto_post = $6)
    AND ($7::text IS NULL OR template_name ILIKE '%' || $7 || '%')
ORDER BY next_due_date ASC
LIMIT $9 OFFSET $8
`

type ListRecurringTransactionsWithFiltersParams struct {
	UserID       uuid.UUID  `json:"user_id"`
	AccountID    *uuid.UUID `json:"account_id"`
	CategoryID   *uuid.UUID `json:"category_id"`
	Frequency    *string    `json:"frequency"`
	IsPaused     *bool      `json:"is_paused"`
	AutoPost     *bool      `json:"auto_post"`
	TemplateName *string    `json:"template_name"`
	Offset       int64      `json:"offset"`
	Limit        int64      `json:"limit"`
}

func (q *Queries) ListRecurringTransactionsWithFilters(ctx context.Context, arg ListRecurringTransactionsWithFiltersParams) ([]RecurringTransaction, error) {
	rows, err := q.db.Query(ctx, listRecurringTransactionsWithFilters,
		arg.UserID,
		arg.AccountID,
		arg.CategoryID,
		arg.Frequency,
		arg.IsPaused,
		arg.AutoPost,
		arg.TemplateName,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RecurringTransaction{}
	for rows.Next() {
		var i RecurringTransaction
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AccountID,
			&i.CategoryID,
			&i.DestinationAccountID,
			&i.Amount,
			&i.Type,
			&i.Description,
			&i.Details,
			&i.Frequency,
			&i.FrequencyInterval,
			&i.FrequencyData,
			&i.StartDate,
			&i.EndDate,
			&i.LastGeneratedDate,
			&i.NextDueDate,
			&i.AutoPost,
			&i.IsPaused,
			&i.MaxOccurrences,
			&i.OccurrencesCount,
			&i.TemplateName,
			&i.Tags,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pauseRecurringTransaction = `-- name: PauseRecurringTransaction :one
UPDATE recurring_transactions
SET is_paused = $2, updated_at = current_timestamp
WHERE id = $1 AND user_id = $3 AND deleted_at IS NULL
RETURNING id, user_id, account_id, category_id, destination_account_id, amount, type, description, details, frequency, frequency_interval, frequency_data, start_date, end_date, last_generated_date, next_due_date, auto_post, is_paused, max_occurrences, occurrences_count, template_name, tags, created_at, updated_at, deleted_at
`

type PauseRecurringTransactionParams struct {
	ID       uuid.UUID `json:"id"`
	IsPaused bool      `json:"is_paused"`
	UserID   uuid.UUID `json:"user_id"`
}

func (q *Queries) PauseRecurringTransaction(ctx context.Context, arg PauseRecurringTransactionParams) (RecurringTransaction, error) {
	row := q.db.QueryRow(ctx, pauseRecurringTransaction, arg.ID, arg.IsPaused, arg.UserID)
	var i RecurringTransaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AccountID,
		&i.CategoryID,
		&i.DestinationAccountID,
		&i.Amount,
		&i.Type,
		&i.Description,
		&i.Details,
		&i.Frequency,
		&i.FrequencyInterval,
		&i.FrequencyData,
		&i.StartDate,
		&i.EndDate,
		&i.LastGeneratedDate,
		&i.NextDueDate,
		&i.AutoPost,
		&i.IsPaused,
		&i.MaxOccurrences,
		&i.OccurrencesCount,
		&i.TemplateName,
		&i.Tags,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateRecurringTransaction = `-- name: UpdateRecurringTransaction :one
UPDATE recurring_transactions
SET
    account_id = COALESCE($3, account_id),
    category_id = COALESCE($4, category_id),
    destination_account_id = COALESCE($5, destination_account_id),
    amount = COALESCE($6, amount),
    type = COALESCE($7, type),
    description = COALESCE($8, description),
    details = COALESCE($9, details),
    frequency = COALESCE($10, frequency),
    frequency_interval = COALESCE($11, frequency_interval),
    frequency_data = COALESCE($12, frequency_data),
    start_date = COALESCE($13, start_date),
    end_date = COALESCE($14, end_date),
    next_due_date = COALESCE($15, next_due_date),
    auto_post = COALESCE($16, auto_post),
    is_paused = COALESCE($17, is_paused),
    max_occurrences = COALESCE($18, max_occurrences),
    template_name = COALESCE($19, template_name),
    tags = COALESCE($20, tags),
    updated_at = current_timestamp
WHERE id = $1 AND user_id = $2 AND deleted_at IS NULL
RETURNING id, user_id, account_id, category_id, destination_account_id, amount, type, description, details, frequency, frequency_interval, frequency_data, start_date, end_date, last_generated_date, next_due_date, auto_post, is_paused, max_occurrences, occurrences_count, template_name, tags, created_at, updated_at, deleted_at
`

type UpdateRecurringTransactionParams struct {
	ID                   uuid.UUID           `json:"id"`
	UserID               uuid.UUID           `json:"user_id"`
	AccountID            *uuid.UUID          `json:"account_id"`
	CategoryID           *uuid.UUID          `json:"category_id"`
	DestinationAccountID *uuid.UUID          `json:"destination_account_id"`
	Amount               decimal.NullDecimal `json:"amount"`
	Type                 *string             `json:"type"`
	Description          *string             `json:"description"`
	Details              *dto.Details        `json:"details"`
	Frequency            *string             `json:"frequency"`
	FrequencyInterval    *int32              `json:"frequency_interval"`
	FrequencyData        []byte              `json:"frequency_data"`
	StartDate            pgtype.Timestamptz  `json:"start_date"`
	EndDate              pgtype.Timestamptz  `json:"end_date"`
	NextDueDate          pgtype.Timestamptz  `json:"next_due_date"`
	AutoPost             *bool               `json:"auto_post"`
	IsPaused             *bool               `json:"is_paused"`
	MaxOccurrences       *int32              `json:"max_occurrences"`
	TemplateName         *string             `json:"template_name"`
	Tags                 []byte              `json:"tags"`
}

func (q *Queries) UpdateRecurringTransaction(ctx context.Context, arg UpdateRecurringTransactionParams) (RecurringTransaction, error) {
	row := q.db.QueryRow(ctx, updateRecurringTransaction,
		arg.ID,
		arg.UserID,
		arg.AccountID,
		arg.CategoryID,
		arg.DestinationAccountID,
		arg.Amount,
		arg.Type,
		arg.Description,
		arg.Details,
		arg.Frequency,
		arg.FrequencyInterval,
		arg.FrequencyData,
		arg.StartDate,
		arg.EndDate,
		arg.NextDueDate,
		arg.AutoPost,
		arg.IsPaused,
		arg.MaxOccurrences,
		arg.TemplateName,
		arg.Tags,
	)
	var i RecurringTransaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AccountID,
		&i.CategoryID,
		&i.DestinationAccountID,
		&i.Amount,
		&i.Type,
		&i.Description,
		&i.Details,
		&i.Frequency,
		&i.FrequencyInterval,
		&i.FrequencyData,
		&i.StartDate,
		&i.EndDate,
		&i.LastGeneratedDate,
		&i.NextDueDate,
		&i.AutoPost,
		&i.IsPaused,
		&i.MaxOccurrences,
		&i.OccurrencesCount,
		&i.TemplateName,
		&i.Tags,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateRecurringTransactionAfterGeneration = `-- name: UpdateRecurringTransactionAfterGeneration :exec
UPDATE recurring_transactions
SET
    last_generated_date = $2,
    next_due_date = $3,
    occurrences_count = occurrences_count + 1,
    updated_at = current_timestamp
WHERE id = $1
`

type UpdateRecurringTransactionAfterGenerationParams struct {
	ID                uuid.UUID          `json:"id"`
	LastGeneratedDate pgtype.Timestamptz `json:"last_generated_date"`
	NextDueDate       pgtype.Timestamptz `json:"next_due_date"`
}

func (q *Queries) UpdateRecurringTransactionAfterGeneration(ctx context.Context, arg UpdateRecurringTransactionAfterGenerationParams) error {
	_, err := q.db.Exec(ctx, updateRecurringTransactionAfterGeneration, arg.ID, arg.LastGeneratedDate, arg.NextDueDate)
	return err
}

const updateRecurringTransactionNextDueDate = `-- name: UpdateRecurringTransactionNextDueDate :one
UPDATE recurring_transactions
SET
    next_due_date = $2,
    updated_at = current_timestamp
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, user_id, account_id, category_id, destination_account_id, amount, type, description, details, frequency, frequency_interval, frequency_data, start_date, end_date, last_generated_date, next_due_date, auto_post, is_paused, max_occurrences, occurrences_count, template_name, tags, created_at, updated_at, deleted_at
`

type UpdateRecurringTransactionNextDueDateParams struct {
	ID          uuid.UUID          `json:"id"`
	NextDueDate pgtype.Timestamptz `json:"next_due_date"`
}

func (q *Queries) UpdateRecurringTransactionNextDueDate(ctx context.Context, arg UpdateRecurringTransactionNextDueDateParams) (RecurringTransaction, error) {
	row := q.db.QueryRow(ctx, updateRecurringTransactionNextDueDate, arg.ID, arg.NextDueDate)
	var i RecurringTransaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AccountID,
		&i.CategoryID,
		&i.DestinationAccountID,
		&i.Amount,
		&i.Type,
		&i.Description,
		&i.Details,
		&i.Frequency,
		&i.FrequencyInterval,
		&i.FrequencyData,
		&i.StartDate,
		&i.EndDate,
		&i.LastGeneratedDate,
		&i.NextDueDate,
		&i.AutoPost,
		&i.IsPaused,
		&i.MaxOccurrences,
		&i.OccurrencesCount,
		&i.TemplateName,
		&i.Tags,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
