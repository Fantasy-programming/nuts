// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: connections.sql

package repository

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createConnection = `-- name: CreateConnection :one
INSERT INTO user_financial_connections (
    user_id,
    provider_name,
    access_token_encrypted,
    item_id,
    institution_id,
    institution_name,
    status,
    last_sync_at,
    expires_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, user_id, provider_name, access_token_encrypted, item_id, institution_id, institution_name, status, last_sync_at, expires_at, created_at, updated_at
`

type CreateConnectionParams struct {
	UserID               uuid.UUID          `json:"user_id"`
	ProviderName         string             `json:"provider_name"`
	AccessTokenEncrypted string             `json:"access_token_encrypted"`
	ItemID               *string            `json:"item_id"`
	InstitutionID        *string            `json:"institution_id"`
	InstitutionName      *string            `json:"institution_name"`
	Status               *string            `json:"status"`
	LastSyncAt           pgtype.Timestamptz `json:"last_sync_at"`
	ExpiresAt            pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) CreateConnection(ctx context.Context, arg CreateConnectionParams) (UserFinancialConnection, error) {
	row := q.db.QueryRow(ctx, createConnection,
		arg.UserID,
		arg.ProviderName,
		arg.AccessTokenEncrypted,
		arg.ItemID,
		arg.InstitutionID,
		arg.InstitutionName,
		arg.Status,
		arg.LastSyncAt,
		arg.ExpiresAt,
	)
	var i UserFinancialConnection
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProviderName,
		&i.AccessTokenEncrypted,
		&i.ItemID,
		&i.InstitutionID,
		&i.InstitutionName,
		&i.Status,
		&i.LastSyncAt,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteConnection = `-- name: DeleteConnection :exec
DELETE FROM user_financial_connections
WHERE id = $1 AND user_id = $2
`

type DeleteConnectionParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) DeleteConnection(ctx context.Context, arg DeleteConnectionParams) error {
	_, err := q.db.Exec(ctx, deleteConnection, arg.ID, arg.UserID)
	return err
}

const getConnectionByID = `-- name: GetConnectionByID :one
SELECT id, user_id, provider_name, access_token_encrypted, item_id, institution_id, institution_name, status, last_sync_at, expires_at, created_at, updated_at FROM user_financial_connections
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetConnectionByID(ctx context.Context, id uuid.UUID) (UserFinancialConnection, error) {
	row := q.db.QueryRow(ctx, getConnectionByID, id)
	var i UserFinancialConnection
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProviderName,
		&i.AccessTokenEncrypted,
		&i.ItemID,
		&i.InstitutionID,
		&i.InstitutionName,
		&i.Status,
		&i.LastSyncAt,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getConnectionByProviderItemID = `-- name: GetConnectionByProviderItemID :one
SELECT id, user_id, provider_name, access_token_encrypted, item_id, institution_id, institution_name, status, last_sync_at, expires_at, created_at, updated_at FROM user_financial_connections
WHERE user_id = $1
  AND provider_name = $2
  AND item_id = $3
LIMIT 1
`

type GetConnectionByProviderItemIDParams struct {
	UserID       uuid.UUID `json:"user_id"`
	ProviderName string    `json:"provider_name"`
	ItemID       *string   `json:"item_id"`
}

func (q *Queries) GetConnectionByProviderItemID(ctx context.Context, arg GetConnectionByProviderItemIDParams) (UserFinancialConnection, error) {
	row := q.db.QueryRow(ctx, getConnectionByProviderItemID, arg.UserID, arg.ProviderName, arg.ItemID)
	var i UserFinancialConnection
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProviderName,
		&i.AccessTokenEncrypted,
		&i.ItemID,
		&i.InstitutionID,
		&i.InstitutionName,
		&i.Status,
		&i.LastSyncAt,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getConnectionsByUserID = `-- name: GetConnectionsByUserID :many
SELECT id, user_id, provider_name, access_token_encrypted, item_id, institution_id, institution_name, status, last_sync_at, expires_at, created_at, updated_at FROM user_financial_connections
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetConnectionsByUserID(ctx context.Context, userID uuid.UUID) ([]UserFinancialConnection, error) {
	rows, err := q.db.Query(ctx, getConnectionsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserFinancialConnection{}
	for rows.Next() {
		var i UserFinancialConnection
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProviderName,
			&i.AccessTokenEncrypted,
			&i.ItemID,
			&i.InstitutionID,
			&i.InstitutionName,
			&i.Status,
			&i.LastSyncAt,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listConnections = `-- name: ListConnections :many
SELECT id, user_id, provider_name, access_token_encrypted, item_id, institution_id, institution_name, status, last_sync_at, expires_at, created_at, updated_at FROM user_financial_connections
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListConnectionsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListConnections(ctx context.Context, arg ListConnectionsParams) ([]UserFinancialConnection, error) {
	rows, err := q.db.Query(ctx, listConnections, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserFinancialConnection{}
	for rows.Next() {
		var i UserFinancialConnection
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProviderName,
			&i.AccessTokenEncrypted,
			&i.ItemID,
			&i.InstitutionID,
			&i.InstitutionName,
			&i.Status,
			&i.LastSyncAt,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setConnectionErrorStatus = `-- name: SetConnectionErrorStatus :one
UPDATE user_financial_connections
SET
    status = $2, -- Should be an error status
    updated_at = NOW()
WHERE id = $1 AND user_id = $3
RETURNING id, user_id, provider_name, access_token_encrypted, item_id, institution_id, institution_name, status, last_sync_at, expires_at, created_at, updated_at
`

type SetConnectionErrorStatusParams struct {
	ID     uuid.UUID `json:"id"`
	Status *string   `json:"status"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) SetConnectionErrorStatus(ctx context.Context, arg SetConnectionErrorStatusParams) (UserFinancialConnection, error) {
	row := q.db.QueryRow(ctx, setConnectionErrorStatus, arg.ID, arg.Status, arg.UserID)
	var i UserFinancialConnection
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProviderName,
		&i.AccessTokenEncrypted,
		&i.ItemID,
		&i.InstitutionID,
		&i.InstitutionName,
		&i.Status,
		&i.LastSyncAt,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const setConnectionSyncStatus = `-- name: SetConnectionSyncStatus :one
UPDATE user_financial_connections
SET
    status = $2,
    last_sync_at = $3,
    updated_at = NOW()
WHERE id = $1 AND user_id = $4
RETURNING id, user_id, provider_name, access_token_encrypted, item_id, institution_id, institution_name, status, last_sync_at, expires_at, created_at, updated_at
`

type SetConnectionSyncStatusParams struct {
	ID         uuid.UUID          `json:"id"`
	Status     *string            `json:"status"`
	LastSyncAt pgtype.Timestamptz `json:"last_sync_at"`
	UserID     uuid.UUID          `json:"user_id"`
}

func (q *Queries) SetConnectionSyncStatus(ctx context.Context, arg SetConnectionSyncStatusParams) (UserFinancialConnection, error) {
	row := q.db.QueryRow(ctx, setConnectionSyncStatus,
		arg.ID,
		arg.Status,
		arg.LastSyncAt,
		arg.UserID,
	)
	var i UserFinancialConnection
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProviderName,
		&i.AccessTokenEncrypted,
		&i.ItemID,
		&i.InstitutionID,
		&i.InstitutionName,
		&i.Status,
		&i.LastSyncAt,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateConnection = `-- name: UpdateConnection :one
UPDATE user_financial_connections
SET
    access_token_encrypted = COALESCE($1, access_token_encrypted),
    item_id = COALESCE($2, item_id),
    institution_id = COALESCE($3, institution_id),
    institution_name = COALESCE($4, institution_name),
    status = COALESCE($5, status),
    last_sync_at = $6, -- Use sqlc.narg for nullable timestamp
    expires_at = $7,   -- Use sqlc.narg for nullable timestamp
    updated_at = NOW()
WHERE id = $8 AND user_id = $9
RETURNING id, user_id, provider_name, access_token_encrypted, item_id, institution_id, institution_name, status, last_sync_at, expires_at, created_at, updated_at
`

type UpdateConnectionParams struct {
	AccessTokenEncrypted *string            `json:"access_token_encrypted"`
	ItemID               *string            `json:"item_id"`
	InstitutionID        *string            `json:"institution_id"`
	InstitutionName      *string            `json:"institution_name"`
	Status               *string            `json:"status"`
	LastSyncAt           pgtype.Timestamptz `json:"last_sync_at"`
	ExpiresAt            pgtype.Timestamptz `json:"expires_at"`
	ID                   uuid.UUID          `json:"id"`
	UserID               uuid.UUID          `json:"user_id"`
}

func (q *Queries) UpdateConnection(ctx context.Context, arg UpdateConnectionParams) (UserFinancialConnection, error) {
	row := q.db.QueryRow(ctx, updateConnection,
		arg.AccessTokenEncrypted,
		arg.ItemID,
		arg.InstitutionID,
		arg.InstitutionName,
		arg.Status,
		arg.LastSyncAt,
		arg.ExpiresAt,
		arg.ID,
		arg.UserID,
	)
	var i UserFinancialConnection
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProviderName,
		&i.AccessTokenEncrypted,
		&i.ItemID,
		&i.InstitutionID,
		&i.InstitutionName,
		&i.Status,
		&i.LastSyncAt,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
