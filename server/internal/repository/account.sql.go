// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: account.sql

package repository

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

type BatchCreateAccountParams struct {
	CreatedBy         *uuid.UUID     `json:"created_by"`
	Name              string         `json:"name"`
	Type              interface{}    `json:"type"`
	Subtype           *string        `json:"subtype"`
	Balance           pgtype.Numeric `json:"balance"`
	Currency          string         `json:"currency"`
	Color             interface{}    `json:"color"`
	Meta              []byte         `json:"meta"`
	ConnectionID      *uuid.UUID     `json:"connection_id"`
	IsExternal        *bool          `json:"is_external"`
	ProviderAccountID *string        `json:"provider_account_id"`
	ProviderName      *string        `json:"provider_name"`
}

const createAccount = `-- name: CreateAccount :one
INSERT INTO accounts (
    created_by,
    name,
    type,
    subtype,
    balance,
    currency,
    color,
    meta,
    connection_id,
    is_external,
    provider_account_id,
    provider_name
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
) RETURNING id, name, type, balance, currency, color, meta, created_by, updated_by, created_at, updated_at, deleted_at, is_external, provider_account_id, provider_name, sync_status, last_synced_at, connection_id, subtype
`

type CreateAccountParams struct {
	CreatedBy         *uuid.UUID     `json:"created_by"`
	Name              string         `json:"name"`
	Type              interface{}    `json:"type"`
	Subtype           *string        `json:"subtype"`
	Balance           pgtype.Numeric `json:"balance"`
	Currency          string         `json:"currency"`
	Color             interface{}    `json:"color"`
	Meta              []byte         `json:"meta"`
	ConnectionID      *uuid.UUID     `json:"connection_id"`
	IsExternal        *bool          `json:"is_external"`
	ProviderAccountID *string        `json:"provider_account_id"`
	ProviderName      *string        `json:"provider_name"`
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) (Account, error) {
	row := q.db.QueryRow(ctx, createAccount,
		arg.CreatedBy,
		arg.Name,
		arg.Type,
		arg.Subtype,
		arg.Balance,
		arg.Currency,
		arg.Color,
		arg.Meta,
		arg.ConnectionID,
		arg.IsExternal,
		arg.ProviderAccountID,
		arg.ProviderName,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Balance,
		&i.Currency,
		&i.Color,
		&i.Meta,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.IsExternal,
		&i.ProviderAccountID,
		&i.ProviderName,
		&i.SyncStatus,
		&i.LastSyncedAt,
		&i.ConnectionID,
		&i.Subtype,
	)
	return i, err
}

const deleteAccount = `-- name: DeleteAccount :exec
UPDATE accounts
SET
    deleted_at = current_timestamp
WHERE id = $1
RETURNING id, name, type, balance, currency, color, meta, created_by, updated_by, created_at, updated_at, deleted_at, is_external, provider_account_id, provider_name, sync_status, last_synced_at, connection_id, subtype
`

func (q *Queries) DeleteAccount(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAccount, id)
	return err
}

const getAccountBalanceTimeline = `-- name: GetAccountBalanceTimeline :many
WITH relevant_period AS (
    SELECT
        date_trunc('month', now()) - INTERVAL '11 months' AS start_month,
        date_trunc('month', now()) AS end_month,
        now() - INTERVAL '1 year' AS start_boundary
),
months AS (
    -- Generate months for the relevant period
    SELECT generate_series(
        (SELECT start_month FROM relevant_period),
        (SELECT end_month FROM relevant_period),
        INTERVAL '1 month'
    ) AS month
),
account_info AS (
    -- Get account creation date
    SELECT created_at
    FROM accounts
    WHERE accounts.id = $1
),
initial_balance AS (
     -- Calculate balance for the specific account just BEFORE the start_month
    SELECT
        COALESCE(sum(
            CASE
                WHEN t.type = 'income' THEN t.amount
                WHEN t.type = 'expense' THEN -t.amount
                WHEN t.type = 'transfer' AND t.account_id = $1 THEN -t.amount -- Source
                WHEN t.type = 'transfer' AND t.destination_account_id = $1 THEN t.amount -- Destination
                ELSE 0
            END
        ), 0)::DECIMAL AS balance_before_period
    FROM transactions t
    WHERE t.account_id = $1 OR t.destination_account_id = $1 -- Consider transfers in/out
      AND t.transaction_datetime < (SELECT start_month FROM relevant_period)
      -- Assuming created_by check is handled by ensuring $1 belongs to the user in app logic
),
monthly_transactions AS (
    -- Aggregate transactions per month for the specific account WITHIN the period
    SELECT
        date_trunc('month', t.transaction_datetime) AS month,
        sum(
            CASE
                WHEN t.type = 'income' THEN t.amount
                WHEN t.type = 'expense' THEN -t.amount
                WHEN t.type = 'transfer' AND t.account_id = $1 THEN -t.amount -- Source
                WHEN t.type = 'transfer' AND t.destination_account_id = $1 THEN t.amount -- Destination
                ELSE 0
            END
        ) AS monthly_net
    FROM transactions t
    WHERE (t.account_id = $1 OR t.destination_account_id = $1) -- Consider transfers in/out
      AND t.transaction_datetime >= (SELECT start_month FROM relevant_period)
      AND t.transaction_datetime < ( (SELECT end_month FROM relevant_period) + INTERVAL '1 month')
    GROUP BY month
),
combined AS (
    -- Combine months, initial balance, and monthly nets
    SELECT
        m.month,
        COALESCE(ib.balance_before_period, 0) AS initial_balance,
        COALESCE(mt.monthly_net, 0) AS monthly_net
    FROM months m
    CROSS JOIN initial_balance ib
    LEFT JOIN monthly_transactions mt ON m.month = mt.month
    JOIN account_info ai ON m.month >= date_trunc('month', ai.created_at) -- Filter months before account creation
),
running_balance AS (
    -- Compute cumulative balance including the initial balance
    SELECT
        c.month,
        c.initial_balance + sum(c.monthly_net) OVER (
            ORDER BY c.month
            ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
        ) AS balance
    FROM combined c
)
SELECT
    month::TIMESTAMPTZ,
    balance::DECIMAL
FROM running_balance
ORDER BY month
`

type GetAccountBalanceTimelineRow struct {
	Month   time.Time      `json:"month"`
	Balance pgtype.Numeric `json:"balance"`
}

// Changed to :many as it returns multiple rows (one per month)
func (q *Queries) GetAccountBalanceTimeline(ctx context.Context, id uuid.UUID) ([]GetAccountBalanceTimelineRow, error) {
	rows, err := q.db.Query(ctx, getAccountBalanceTimeline, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAccountBalanceTimelineRow{}
	for rows.Next() {
		var i GetAccountBalanceTimelineRow
		if err := rows.Scan(&i.Month, &i.Balance); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAccountById = `-- name: GetAccountById :one
SELECT
    id,
    name,
    type,
    subtype,
    balance,
    currency,
    meta,
    color,
    created_by,
    updated_at,
    connection_id
FROM accounts
WHERE
    id = $1
    AND deleted_at IS NULL
LIMIT 1
`

type GetAccountByIdRow struct {
	ID           uuid.UUID      `json:"id"`
	Name         string         `json:"name"`
	Type         ACCOUNTTYPE    `json:"type"`
	Subtype      *string        `json:"subtype"`
	Balance      pgtype.Numeric `json:"balance"`
	Currency     string         `json:"currency"`
	Meta         []byte         `json:"meta"`
	Color        COLORENUM      `json:"color"`
	CreatedBy    *uuid.UUID     `json:"created_by"`
	UpdatedAt    time.Time      `json:"updated_at"`
	ConnectionID *uuid.UUID     `json:"connection_id"`
}

func (q *Queries) GetAccountById(ctx context.Context, id uuid.UUID) (GetAccountByIdRow, error) {
	row := q.db.QueryRow(ctx, getAccountById, id)
	var i GetAccountByIdRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Subtype,
		&i.Balance,
		&i.Currency,
		&i.Meta,
		&i.Color,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.ConnectionID,
	)
	return i, err
}

const getAccountByProviderAccountID = `-- name: GetAccountByProviderAccountID :one

SELECT
    id,
    name,
    type,
    subtype,
    balance,
    currency,
    color,
    meta,
    created_by,
    updated_at,
    connection_id,
    provider_name,
    provider_account_id
FROM accounts
WHERE
    provider_account_id = $1
    AND created_by = $2 -- user_id
    AND deleted_at IS NULL
LIMIT 1
`

type GetAccountByProviderAccountIDParams struct {
	ProviderAccountID *string    `json:"provider_account_id"`
	CreatedBy         *uuid.UUID `json:"created_by"`
}

type GetAccountByProviderAccountIDRow struct {
	ID                uuid.UUID      `json:"id"`
	Name              string         `json:"name"`
	Type              ACCOUNTTYPE    `json:"type"`
	Subtype           *string        `json:"subtype"`
	Balance           pgtype.Numeric `json:"balance"`
	Currency          string         `json:"currency"`
	Color             COLORENUM      `json:"color"`
	Meta              []byte         `json:"meta"`
	CreatedBy         *uuid.UUID     `json:"created_by"`
	UpdatedAt         time.Time      `json:"updated_at"`
	ConnectionID      *uuid.UUID     `json:"connection_id"`
	ProviderName      *string        `json:"provider_name"`
	ProviderAccountID *string        `json:"provider_account_id"`
}

// Or other desired order
func (q *Queries) GetAccountByProviderAccountID(ctx context.Context, arg GetAccountByProviderAccountIDParams) (GetAccountByProviderAccountIDRow, error) {
	row := q.db.QueryRow(ctx, getAccountByProviderAccountID, arg.ProviderAccountID, arg.CreatedBy)
	var i GetAccountByProviderAccountIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Subtype,
		&i.Balance,
		&i.Currency,
		&i.Color,
		&i.Meta,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.ConnectionID,
		&i.ProviderName,
		&i.ProviderAccountID,
	)
	return i, err
}

const getAccounts = `-- name: GetAccounts :many
SELECT
    id,
    name,
    type,
    subtype,
    balance,
    currency,
    color,
    meta,
    updated_at,
    connection_id
FROM accounts
WHERE
    created_by = $1
    AND deleted_at IS NULL
`

type GetAccountsRow struct {
	ID           uuid.UUID      `json:"id"`
	Name         string         `json:"name"`
	Type         ACCOUNTTYPE    `json:"type"`
	Subtype      *string        `json:"subtype"`
	Balance      pgtype.Numeric `json:"balance"`
	Currency     string         `json:"currency"`
	Color        COLORENUM      `json:"color"`
	Meta         []byte         `json:"meta"`
	UpdatedAt    time.Time      `json:"updated_at"`
	ConnectionID *uuid.UUID     `json:"connection_id"`
}

func (q *Queries) GetAccounts(ctx context.Context, userID *uuid.UUID) ([]GetAccountsRow, error) {
	rows, err := q.db.Query(ctx, getAccounts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAccountsRow{}
	for rows.Next() {
		var i GetAccountsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.Subtype,
			&i.Balance,
			&i.Currency,
			&i.Color,
			&i.Meta,
			&i.UpdatedAt,
			&i.ConnectionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAccountsBalanceTimeline = `-- name: GetAccountsBalanceTimeline :many
WITH relevant_period AS (
    SELECT
        date_trunc('month', now()) - INTERVAL '11 months' AS start_month,
        date_trunc('month', now()) AS end_month,
        now() - INTERVAL '1 year' AS start_boundary
),
months AS (
    SELECT generate_series(
        (SELECT start_month FROM relevant_period),
        (SELECT end_month FROM relevant_period),
        INTERVAL '1 month'
    ) AS month
),
account_info AS (
    SELECT
        id AS account_id,
        created_at,
        is_external,
        balance AS db_balance
    FROM accounts
    WHERE
        deleted_at IS NULL
        AND accounts.created_by = $1
),
timeline_transactions AS (
    SELECT
        ai.account_id,
        sum(
            CASE
                WHEN t.type = 'income' THEN t.amount
                WHEN t.type = 'expense' THEN -t.amount
                WHEN t.type = 'transfer' AND t.account_id = ai.account_id THEN -t.amount
                WHEN t.type = 'transfer' AND t.destination_account_id = ai.account_id THEN t.amount
                ELSE 0
            END
        ) AS total_timeline_impact
    FROM account_info ai
    LEFT JOIN transactions t ON (t.account_id = ai.account_id OR t.destination_account_id = ai.account_id)
        AND t.transaction_datetime >= (SELECT start_month FROM relevant_period)
        AND t.transaction_datetime < ((SELECT end_month FROM relevant_period) + INTERVAL '1 month')
        AND t.created_by = $1
    GROUP BY ai.account_id
),
pre_timeline_transactions AS (
    SELECT
        ai.account_id,
        sum(
            CASE
                WHEN t.type = 'income' THEN t.amount
                WHEN t.type = 'expense' THEN -t.amount
                WHEN t.type = 'transfer' AND t.account_id = ai.account_id THEN -t.amount
                WHEN t.type = 'transfer' AND t.destination_account_id = ai.account_id THEN t.amount
                ELSE 0
            END
        ) AS total_pre_timeline_impact,
        COUNT(t.id) AS pre_timeline_transaction_count,
        MIN(t.transaction_datetime) AS earliest_transaction_date
    FROM account_info ai
    LEFT JOIN transactions t ON (t.account_id = ai.account_id OR t.destination_account_id = ai.account_id)
        AND t.transaction_datetime < (SELECT start_month FROM relevant_period)
        AND t.created_by = $1
    GROUP BY ai.account_id
),
initial_balances AS (
    SELECT
        ai.account_id,
        ai.is_external,
        ai.db_balance,
        ptt.earliest_transaction_date,
        CASE
            -- For internal accounts: use calculated balance from all previous transactions
            WHEN NOT ai.is_external THEN 
                COALESCE(ptt.total_pre_timeline_impact, 0)
            
            -- For external accounts WITHOUT any transactions: use DB balance (flat line)
            WHEN ai.is_external AND (ptt.pre_timeline_transaction_count = 0 OR ptt.pre_timeline_transaction_count IS NULL) 
                 AND (tt.total_timeline_impact = 0 OR tt.total_timeline_impact IS NULL) THEN 
                ai.db_balance
            
            -- For external accounts WITH transactions: work backwards from current DB balance
            -- Initial balance = current_balance - all_known_transaction_impacts
            WHEN ai.is_external THEN 
                ai.db_balance - COALESCE(tt.total_timeline_impact, 0) - COALESCE(ptt.total_pre_timeline_impact, 0)
            
            ELSE 0
        END AS calculated_initial_balance,
        ptt.pre_timeline_transaction_count,
        tt.total_timeline_impact
    FROM account_info ai
    LEFT JOIN pre_timeline_transactions ptt ON ai.account_id = ptt.account_id
    LEFT JOIN timeline_transactions tt ON ai.account_id = tt.account_id
),
monthly_transactions AS (
    SELECT
        ai.account_id,
        date_trunc('month', t.transaction_datetime) AS month,
        sum(
            CASE
                 WHEN t.type = 'income' THEN t.amount
                 WHEN t.type = 'expense' THEN -t.amount
                 WHEN t.type = 'transfer' AND t.account_id = ai.account_id THEN -t.amount
                 WHEN t.type = 'transfer' AND t.destination_account_id = ai.account_id THEN t.amount
                 ELSE 0
            END
        ) AS monthly_net
    FROM transactions t
    JOIN account_info ai ON (t.account_id = ai.account_id OR t.destination_account_id = ai.account_id)
    WHERE t.transaction_datetime >= (SELECT start_month FROM relevant_period)
      AND t.transaction_datetime < ((SELECT end_month FROM relevant_period) + INTERVAL '1 month')
      AND t.created_by = $1
    GROUP BY ai.account_id, month
),

combined AS (
    SELECT
        m.month,
        ai.account_id,
        ai.is_external,
        ai.db_balance,
        ib.calculated_initial_balance AS initial_balance,
        COALESCE(mt.monthly_net, 0) AS monthly_net,
        ib.earliest_transaction_date
    FROM months m
    CROSS JOIN account_info ai
    LEFT JOIN initial_balances ib ON ai.account_id = ib.account_id
    LEFT JOIN monthly_transactions mt ON ai.account_id = mt.account_id AND m.month = mt.month
    WHERE 
        -- For internal accounts: include from account creation date
        (NOT ai.is_external AND m.month >= date_trunc('month', ai.created_at))
        OR
        -- For external accounts WITH transactions: include from earliest transaction date
        (ai.is_external AND ib.earliest_transaction_date IS NOT NULL 
         AND m.month >= date_trunc('month', ib.earliest_transaction_date))
        OR
        -- For external accounts WITHOUT transactions: include from timeline start (they have balance but no transaction history)
        (ai.is_external AND ib.earliest_transaction_date IS NULL 
         AND m.month >= (SELECT start_month FROM relevant_period))
),
running_balance AS (
    SELECT
        c.month,
        c.account_id,
        c.is_external,
        c.db_balance,
        CASE
            -- For external accounts without any transactions: use DB balance (flat line)
            WHEN c.is_external AND c.earliest_transaction_date IS NULL THEN 
                c.db_balance
            
            -- For all other accounts (internal + external with transactions): 
            -- calculate running balance from our computed initial balance
            ELSE c.initial_balance + sum(c.monthly_net) OVER (
                PARTITION BY c.account_id
                ORDER BY c.month
                ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
            )
        END AS balance
    FROM combined c
)
SELECT
    rb.month::TIMESTAMPTZ as month,
    sum(rb.balance)::DECIMAL AS balance
FROM running_balance rb
GROUP BY rb.month
ORDER BY rb.month
`

type GetAccountsBalanceTimelineRow struct {
	Month   time.Time      `json:"month"`
	Balance pgtype.Numeric `json:"balance"`
}

// Calculate what transactions we have BEFORE our timeline period
// Final sum of balances across all accounts per month
func (q *Queries) GetAccountsBalanceTimeline(ctx context.Context, userID *uuid.UUID) ([]GetAccountsBalanceTimelineRow, error) {
	rows, err := q.db.Query(ctx, getAccountsBalanceTimeline, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAccountsBalanceTimelineRow{}
	for rows.Next() {
		var i GetAccountsBalanceTimelineRow
		if err := rows.Scan(&i.Month, &i.Balance); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAccountsByConnectionID = `-- name: GetAccountsByConnectionID :many
SELECT
    id,
    name,
    type,
    subtype,
    balance,
    currency,
    color,
    meta,
    created_by,
    updated_at,
    connection_id,
    provider_name,
    provider_account_id
FROM accounts
WHERE
    connection_id = $1
    AND created_by = $2 -- user_id
    AND deleted_at IS NULL
`

type GetAccountsByConnectionIDParams struct {
	ConnectionID *uuid.UUID `json:"connection_id"`
	CreatedBy    *uuid.UUID `json:"created_by"`
}

type GetAccountsByConnectionIDRow struct {
	ID                uuid.UUID      `json:"id"`
	Name              string         `json:"name"`
	Type              ACCOUNTTYPE    `json:"type"`
	Subtype           *string        `json:"subtype"`
	Balance           pgtype.Numeric `json:"balance"`
	Currency          string         `json:"currency"`
	Color             COLORENUM      `json:"color"`
	Meta              []byte         `json:"meta"`
	CreatedBy         *uuid.UUID     `json:"created_by"`
	UpdatedAt         time.Time      `json:"updated_at"`
	ConnectionID      *uuid.UUID     `json:"connection_id"`
	ProviderName      *string        `json:"provider_name"`
	ProviderAccountID *string        `json:"provider_account_id"`
}

func (q *Queries) GetAccountsByConnectionID(ctx context.Context, arg GetAccountsByConnectionIDParams) ([]GetAccountsByConnectionIDRow, error) {
	rows, err := q.db.Query(ctx, getAccountsByConnectionID, arg.ConnectionID, arg.CreatedBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAccountsByConnectionIDRow{}
	for rows.Next() {
		var i GetAccountsByConnectionIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.Subtype,
			&i.Balance,
			&i.Currency,
			&i.Color,
			&i.Meta,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.ConnectionID,
			&i.ProviderName,
			&i.ProviderAccountID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAccountsWithTrend = `-- name: GetAccountsWithTrend :many
WITH period AS (
    SELECT
        $1::TIMESTAMPTZ AS start_date,
        $2::TIMESTAMPTZ AS end_date
),

date_series AS (
    SELECT generate_series(
        (SELECT start_date FROM period),
        (SELECT end_date FROM period),
        '1 day'
    )::DATE AS date
),

account_info AS (
    -- Get account info, including creation date
    SELECT
        id AS account_id,
        name,
        type,
        subtype,
        currency,
        color,
        meta,
        created_by,
        created_at,
        updated_at,
        deleted_at
    FROM accounts
    WHERE accounts.created_by = $3
    -- Include accounts active at any point during the period
    AND created_at <= (SELECT end_date FROM period)
    AND (deleted_at IS NULL OR deleted_at > (SELECT start_date FROM period))
),

balance_calc AS (
    -- Calculate balance at the start and end of the period for each account
    SELECT
        ai.account_id,
        -- Balance just BEFORE start_date
        coalesce(sum(
            CASE
                WHEN t.transaction_datetime < (SELECT start_date FROM period) THEN
                    CASE
                        WHEN t.type = 'income' THEN t.amount
                        WHEN t.type = 'expense' THEN -t.amount
                        WHEN t.type = 'transfer' AND t.account_id = t.account_id THEN -t.amount
                        WHEN t.type = 'transfer' AND t.account_id = t.destination_account_id THEN t.amount
                        ELSE 0
                    END
                ELSE 0
            END
        ), 0)::DECIMAL AS start_balance,
        -- Balance AT end_date (inclusive)
        coalesce(sum(
            CASE
                WHEN t.transaction_datetime <= (SELECT end_date FROM period)
                    THEN
                        CASE
                            WHEN t.type = 'income' THEN t.amount
                            WHEN t.type = 'expense' THEN -t.amount
                            WHEN t.type = 'transfer' AND t.account_id = t.account_id THEN -t.amount
                            WHEN t.type = 'transfer' AND t.account_id = t.destination_account_id THEN t.amount
                            ELSE 0
                        END
                ELSE 0
            END
        ), 0)::DECIMAL AS end_balance
    FROM transactions t
    JOIN account_info ai ON (t.account_id = ai.account_id OR t.destination_account_id = ai.account_id)
    WHERE t.created_by = $3
      AND t.transaction_datetime <= (SELECT end_date FROM period)
      -- Filter transactions related to the accounts active in the period
    GROUP BY ai.account_id
),

account_trend AS (
    -- Calculate trend percentage based on actual start/end balances
    SELECT
        ai.account_id,
        ai.name,
        ai.type,
        ai.subtype,
        coalesce(bc.end_balance, 0) AS balance, -- Current balance is the end_balance
        ai.currency,
        ai.color,
        ai.meta,
        ai.updated_at,
        CASE
            -- Avoid division by zero if start_balance is 0
            WHEN coalesce(bc.start_balance, 0) = 0 THEN
                CASE
                    -- If end balance is also 0, trend is 0
                    WHEN coalesce(bc.end_balance, 0) = 0 THEN 0
                    -- If start is 0 but end is positive/negative, trend is infinite (represent as 100% or specific value?)
                    -- Let's return 100% if end > start (0), -100% if end < start (0). Or null? Let's use 100/-100 for simplicity.
                    WHEN coalesce(bc.end_balance, 0) > 0 THEN 100.0
                    ELSE -100.0 -- or potentially 0 or NULL depending on desired behaviour
                END
            -- Normal trend calculation
            ELSE
                ( (coalesce(bc.end_balance, 0) - bc.start_balance) / ABS(bc.start_balance) * 100.0 )
        END::DECIMAL AS trend
    FROM account_info ai
    LEFT JOIN balance_calc bc ON ai.account_id = bc.account_id
    -- Ensure we only consider the balance if the account existed at the start date for trend calculation
    -- If created within the period, trend starts from 0.
    WHERE ai.created_at <= (SELECT end_date FROM period) -- Redundant check, but safe
      AND (ai.deleted_at IS NULL OR ai.deleted_at > (SELECT start_date FROM period)) -- Ensure not deleted before period start
),

balance_timeseries AS (
    SELECT
        ai.account_id,
        ds.date,
        sum(
            CASE
                WHEN t.type = 'income' THEN t.amount
                WHEN t.type = 'expense' THEN -t.amount
                WHEN t.type = 'transfer' AND t.account_id = ai.account_id THEN -t.amount
                WHEN t.type = 'transfer' AND t.destination_account_id = ai.account_id THEN t.amount
                ELSE 0
            END
        )::DECIMAL AS cumulative_balance
    FROM account_info ai
    CROSS JOIN date_series ds
    LEFT JOIN transactions t
        ON (t.account_id = ai.account_id OR t.destination_account_id = ai.account_id)
       AND t.transaction_datetime <= ds.date + interval '1 day' - interval '1 second'
       AND t.created_by = $3
    GROUP BY ai.account_id, ds.date
),

aggregated_series AS (
    SELECT
        account_id,
        jsonb_agg(
            jsonb_build_object(
                'date', date,
                'balance', cumulative_balance
            ) ORDER BY date
        ) AS timeseries
    FROM balance_timeseries
    GROUP BY account_id
)
SELECT
    at.account_id as id,
    at.name,
    at.type,
    at.subtype,
    at.balance::DECIMAL as balance, -- Balance at the end_date
    at.currency,
    at.color,
    at.meta,
    at.updated_at,
    at.trend::DECIMAL as trend,
    coalesce(agg.timeseries, '[]'::JSONB)::JSONB AS balance_timeseries
FROM account_trend at
LEFT JOIN aggregated_series agg ON at.account_id = agg.account_id
ORDER BY at.name
`

type GetAccountsWithTrendParams struct {
	Column1 time.Time  `json:"column_1"`
	Column2 time.Time  `json:"column_2"`
	UserID  *uuid.UUID `json:"user_id"`
}

type GetAccountsWithTrendRow struct {
	ID                uuid.UUID      `json:"id"`
	Name              string         `json:"name"`
	Type              ACCOUNTTYPE    `json:"type"`
	Subtype           *string        `json:"subtype"`
	Balance           pgtype.Numeric `json:"balance"`
	Currency          string         `json:"currency"`
	Color             COLORENUM      `json:"color"`
	Meta              []byte         `json:"meta"`
	UpdatedAt         time.Time      `json:"updated_at"`
	Trend             pgtype.Numeric `json:"trend"`
	BalanceTimeseries []byte         `json:"balance_timeseries"`
}

// Final query joining trend with last 3 transactions
func (q *Queries) GetAccountsWithTrend(ctx context.Context, arg GetAccountsWithTrendParams) ([]GetAccountsWithTrendRow, error) {
	rows, err := q.db.Query(ctx, getAccountsWithTrend, arg.Column1, arg.Column2, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAccountsWithTrendRow{}
	for rows.Next() {
		var i GetAccountsWithTrendRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.Subtype,
			&i.Balance,
			&i.Currency,
			&i.Color,
			&i.Meta,
			&i.UpdatedAt,
			&i.Trend,
			&i.BalanceTimeseries,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAccount = `-- name: UpdateAccount :one
UPDATE accounts
SET
    name = coalesce($1, name),
    type = coalesce($2, type),
    subtype = coalesce($3, subtype),
    balance = coalesce($4, balance),
    currency = coalesce($5, currency),
    color = coalesce($6, color),
    meta = coalesce($7, meta),
    updated_by = $8
WHERE id = $9
RETURNING id, name, type, balance, currency, color, meta, created_by, updated_by, created_at, updated_at, deleted_at, is_external, provider_account_id, provider_name, sync_status, last_synced_at, connection_id, subtype
`

type UpdateAccountParams struct {
	Name      *string        `json:"name"`
	Type      interface{}    `json:"type"`
	Subtype   *string        `json:"subtype"`
	Balance   pgtype.Numeric `json:"balance"`
	Currency  *string        `json:"currency"`
	Color     interface{}    `json:"color"`
	Meta      []byte         `json:"meta"`
	UpdatedBy *uuid.UUID     `json:"updated_by"`
	ID        uuid.UUID      `json:"id"`
}

func (q *Queries) UpdateAccount(ctx context.Context, arg UpdateAccountParams) (Account, error) {
	row := q.db.QueryRow(ctx, updateAccount,
		arg.Name,
		arg.Type,
		arg.Subtype,
		arg.Balance,
		arg.Currency,
		arg.Color,
		arg.Meta,
		arg.UpdatedBy,
		arg.ID,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Balance,
		&i.Currency,
		&i.Color,
		&i.Meta,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.IsExternal,
		&i.ProviderAccountID,
		&i.ProviderName,
		&i.SyncStatus,
		&i.LastSyncedAt,
		&i.ConnectionID,
		&i.Subtype,
	)
	return i, err
}

const updateAccountBalance = `-- name: UpdateAccountBalance :exec
UPDATE accounts
SET balance = balance + $2
WHERE id = $1
`

type UpdateAccountBalanceParams struct {
	ID      uuid.UUID      `json:"id"`
	Balance pgtype.Numeric `json:"balance"`
}

func (q *Queries) UpdateAccountBalance(ctx context.Context, arg UpdateAccountBalanceParams) error {
	_, err := q.db.Exec(ctx, updateAccountBalance, arg.ID, arg.Balance)
	return err
}
